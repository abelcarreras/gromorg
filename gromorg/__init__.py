__version__ = '0.1'
import gmxapi as gmx
import mdtraj
import os
from gromorg.swisparam import SwissParams
from gromorg.utils import extract_energy
import numpy as np
from gromorg.capture import captured_stdout
import shutil


class GromOrg:
    def __init__(self, structure,
                 params=None,
                 box=(10, 10, 10),
                 angles=None,
                 supercell=(1, 1, 1),
                 omp_num_threads=6,
                 silent=False,
                 delete_scratch=True):

        self._structure = structure
        self._filename = 'test'
        self._box = np.array(box)/10.0  # from Angs to nm
        self._supercell = supercell
        self._angles = angles
        self._silent = silent
        self._delete_scratch = delete_scratch

        os.putenv('GMX_MAXBACKUP', '-1')
        os.putenv('OMP_NUM_THREADS', '{}'.format(omp_num_threads))

        self._work_dir = 'gromorg_{}/'.format(os.getpid())
        # os.mkdir(self._work_dir)
        try:
            os.mkdir(self._work_dir)
        except FileExistsError:
            pass

        self._filename_dir = self._work_dir + self._filename

        # Default parameters
        self._params = {# Run paramters
                        'integrator': 'md-vv',     # Verlet integrator
                        'nsteps': 5000,            # 0.001 * 5000 = 50 ps
                        'dt': 0.001,               # ps
                        # Output control
                        'nstxout': 1,              # save coordinates every 0.001 ps
                        'nstvout': 1,              # save velocities every 0.001 ps
                        'nstenergy': 1,            # save energies every 0.001 ps
                        'nstlog': 100,             # update log file every 0.1 ps
                        # Bond parameters
                        'continuation': 'no',       # first dynamics run
                        'cutoff-scheme': 'Verlet',  # Buffered neighbor searching
                        'verlet-buffer-tolerance': 3.3e-03,
                        # 'ns_type': 'grid',          # search neighboring grid cells
                        'nstlist': 10,              # 20 fs, largely irrelevant with Verlet
                        'rcoulomb': 1.0,            # short-range electrostatic cutoff (in nm)
                        'rvdw': 1.0,                # short-range van der Waals cutoff (in nm)
                        'DispCorr': 'EnerPres',     # account for cut-off vdW scheme
                        # Electrostatics
                        'coulombtype': 'PME',       # Particle Mesh Ewald for long-range electrostatics
                        'pme_order': 4,             # cubic interpolation
                        'fourierspacing': 0.16,     # grid spacing for FFT
                        # Temperature coupling is on
                        'tcoupl': 'nose-hoover',    # Nose-Hoover thermostat
                        'tc-grps': 'LIG',           # one coupling group
                        'tau_t': 0.3,               # time constant, in ps
                        'ref_t': 100,               # reference temperature, one for each group, in K
                        # Pressure coupling is off
                        'pcoupl': 'no',             # no pressure coupling in NVT
                        # Periodic boundary conditions
                        'pbc': 'xyz',               # 3-D PBC
                        # Velocity generation
                        'gen_vel': 'yes',           # assign velocities from Maxwell distributio
                        'gen_temp': 10,             # temperature for Maxwell distribution
                        'gen_seed': -1,            # generate a random seed
                        }

        if params is not None:
            self._params.update(params)

    def get_mdp(self):
        file = ';Autogenerated MDP\n'
        for keys, values in self._params.items():
            file += '{:30} = {}\n'.format(keys, values)

        return file

    def get_topology(self):

        num_mol = np.prod(self._supercell)
        file = '; Autogenerated Topology\n'

        itp_files = ['charmm27.ff/forcefield.itp', '{}.itp'.format(self._filename)]

        params = {'system': ['molecular system name'],
                  'molecules': ['{} {}\n'.format(self._filename, num_mol)]}

        for itp in itp_files:
            file += '#include "{}"\n'.format(itp)

        for section, lines in params.items():
            file += '[ {} ]\n'.format(section)
            for line in lines:
                file += '{}\n'.format(line)

        return file

    def get_tpr(self):
        sw = SwissParams(self._structure, silent=self._silent)

        files = {'itp': sw.get_itp_data(),
                 'pdb': sw.get_pdb_data(),
                 'top': self.get_topology(),
                 'mdp': self.get_mdp()}

        for ext, data in files.items():
            with open(self._filename_dir + '.{}'.format(ext), 'w') as f:
                f.write(data)


        #gmx genconf -f molecule.gro -o multi_mol.gro -nbox 2 2 2

        if self._angles is None:
            grompp = gmx.commandline_operation('gmx', 'editconf',
                                               input_files={'-f': self._filename_dir + '.pdb',
                                                            '-box': ['{}'.format(self._box[0]),
                                                                     '{}'.format(self._box[1]),
                                                                     '{}'.format(self._box[2])]},

                                               output_files={'-o': self._filename_dir + '.gro'})
        else:
            grompp = gmx.commandline_operation('gmx',
                                               arguments=['editconf',
                                                          #'-noc'
                                                          ],
                                               input_files={'-f': self._filename_dir + '.pdb',
                                                            '-box': ['{}'.format(self._box[0]),
                                                                     '{}'.format(self._box[1]),
                                                                     '{}'.format(self._box[2])],
                                                            '-bt': 'triclinic',
                                                            '-angles': ['{}'.format(self._angles[0]),
                                                                        '{}'.format(self._angles[1]),
                                                                        '{}'.format(self._angles[2])]
                                                            },
                                               output_files={'-o': self._filename_dir + '.gro'})

        grompp.run()

        if grompp.output.returncode.result() != 0:
            print(grompp.output.erroroutput.result())


        grompp = gmx.commandline_operation('gmx', 'genconf',
                                           input_files={'-f': self._filename_dir + '.gro',
                                                        '-nbox': ['{}'.format(self._supercell[0]),
                                                                  '{}'.format(self._supercell[1]),
                                                                  '{}'.format(self._supercell[2])],
                                                        },
                                           output_files={'-o': self._filename_dir + '.gro'})
        grompp.run()

        if grompp.output.returncode.result() != 0:
            print(grompp.output.erroroutput.result())

        grompp = gmx.commandline_operation('gmx', 'grompp',
                                           input_files={'-f': self._filename_dir + '.mdp',
                                                        '-c': self._filename_dir + '.gro',
                                                        '-p': self._filename_dir + '.top',
                                                        '-po': self._filename_dir + '_log.mdp'},
                                           output_files={'-o': self._filename_dir + '.tpr'})
        grompp.run()

        if grompp.output.returncode.result() != 0:
            print(grompp.output.erroroutput.result())

        tpr_data = gmx.read_tpr(self._filename_dir + '.tpr')

        return tpr_data

    def run_md(self, whole=False):

        md = gmx.mdrun(input=self.get_tpr())

        if self._silent:
            with captured_stdout(self._filename_dir + '.log'):
                md.run()
        else:
            md.run()

        trajectory_file = md.output.trajectory.result()
        md_data_dir = md.output._work_dir.result()

        # print('trajectory file:', trajectory_file)
        # print('workdir: ', md.output._work_dir.result())

        if whole:
            grompp = gmx.commandline_operation('gmx', 'trjconv',
                                               stdin='0',
                                               input_files={'-f': trajectory_file,
                                                            '-s': self._filename_dir + '.tpr',
                                                            '-pbc': 'whole'},
                                               output_files={'-o': md_data_dir + '/{}.trr'.format(self._filename)})

            if grompp.output.returncode.result() != 0:
                print(grompp.output.erroroutput.result())

            trajectory_file = md_data_dir + '/{}.trr'.format(self._filename)

        trajectory = mdtraj.load_trr(trajectory_file, top=md_data_dir + '/confout.gro')

        energy = extract_energy(md_data_dir + '/ener.edr', initial=0)

        if self._delete_scratch:
            import shutil
            shutil.rmtree(md.output._work_dir.result())
            # shutil.rmtree(self._work_dir)

        return trajectory, energy

    def get_forces(self):

        force_input = gmx.modify_input(input=self.get_tpr(), parameters={'nsteps': 1, 'nstfout': 1})

        md = gmx.mdrun(input=force_input)

        if self._silent:
            with captured_stdout(self._filename_dir + '.log'):
                md.run()
        else:
            md.run()

        trajectory_file = md.output.trajectory.result()
        md_data_dir = md.output._work_dir.result()

        # print('trajectory file:', trajectory_file)
        # print('workdir: ', md.output._work_dir.result())

        grompp = gmx.commandline_operation('gmx', ['traj', '-of'],
                                           stdin='0',
                                           input_files={'-f': trajectory_file,
                                                        '-s': self._filename_dir + '.tpr',
                                                        '-b': '0',
                                                        '-e': '0',
                                                        },
                                           # output_files={'-o': md_data_dir + '/{}.trr'.format(self._filename)}
                                           )

        if grompp.output.returncode.result() != 0:
            print(grompp.output.erroroutput.result())

        forces = np.loadtxt('force.xvg', comments=['#', '@'])[1:].reshape(-1, 3)
        os.remove('force.xvg')

        if self._delete_scratch:
            import shutil
            shutil.rmtree(md.output._work_dir.result())

        return forces

    def get_last_structure(self):
        """
        Returns the unitcell of the last step in pyqchem format (ignores supercell)
        Intended to be used for unitcell minimization

        :return:
        """

        trajectory = self.run_md(whole=True)[0]

        last_unit_cell = trajectory.xyz[-1][:self._structure.get_number_of_atoms()]*10 # nm to angs

        cc = np.average(last_unit_cell, axis=0)
        last_unit_cell = last_unit_cell - cc  # centered in zero


        from copy import deepcopy
        opt_structure = deepcopy(self._structure)
        opt_structure.set_coordinates(last_unit_cell)

        return opt_structure

    def __del__(self):
        if os.path.isdir(self._work_dir):
            shutil.rmtree(self._work_dir)


if __name__ == '__main__':
    pass
